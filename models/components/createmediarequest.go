// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/FastPix/fastpix-go/internal/utils"
)

type InputType string

const (
	InputTypeVideoInput     InputType = "VideoInput"
	InputTypeWatermarkInput InputType = "WatermarkInput"
	InputTypeAudioInput     InputType = "AudioInput"
	InputTypeSubtitleInput  InputType = "SubtitleInput"
)

type Input struct {
	VideoInput     *VideoInput     `queryParam:"inline"`
	WatermarkInput *WatermarkInput `queryParam:"inline"`
	AudioInput     *AudioInput     `queryParam:"inline"`
	SubtitleInput  *SubtitleInput  `queryParam:"inline"`

	Type InputType
}

func CreateInputVideoInput(videoInput VideoInput) Input {
	typ := InputTypeVideoInput

	return Input{
		VideoInput: &videoInput,
		Type:       typ,
	}
}

func CreateInputWatermarkInput(watermarkInput WatermarkInput) Input {
	typ := InputTypeWatermarkInput

	return Input{
		WatermarkInput: &watermarkInput,
		Type:           typ,
	}
}

func CreateInputAudioInput(audioInput AudioInput) Input {
	typ := InputTypeAudioInput

	return Input{
		AudioInput: &audioInput,
		Type:       typ,
	}
}

func CreateInputSubtitleInput(subtitleInput SubtitleInput) Input {
	typ := InputTypeSubtitleInput

	return Input{
		SubtitleInput: &subtitleInput,
		Type:          typ,
	}
}

func (u *Input) UnmarshalJSON(data []byte) error {

	var audioInput AudioInput = AudioInput{}
	if err := utils.UnmarshalJSON(data, &audioInput, "", true, true); err == nil {
		u.AudioInput = &audioInput
		u.Type = InputTypeAudioInput
		return nil
	}

	var subtitleInput SubtitleInput = SubtitleInput{}
	if err := utils.UnmarshalJSON(data, &subtitleInput, "", true, true); err == nil {
		u.SubtitleInput = &subtitleInput
		u.Type = InputTypeSubtitleInput
		return nil
	}

	var watermarkInput WatermarkInput = WatermarkInput{}
	if err := utils.UnmarshalJSON(data, &watermarkInput, "", true, true); err == nil {
		u.WatermarkInput = &watermarkInput
		u.Type = InputTypeWatermarkInput
		return nil
	}

	var videoInput VideoInput = VideoInput{}
	if err := utils.UnmarshalJSON(data, &videoInput, "", true, true); err == nil {
		u.VideoInput = &videoInput
		u.Type = InputTypeVideoInput
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Input", string(data))
}

func (u Input) MarshalJSON() ([]byte, error) {
	if u.VideoInput != nil {
		return utils.MarshalJSON(u.VideoInput, "", true)
	}

	if u.WatermarkInput != nil {
		return utils.MarshalJSON(u.WatermarkInput, "", true)
	}

	if u.AudioInput != nil {
		return utils.MarshalJSON(u.AudioInput, "", true)
	}

	if u.SubtitleInput != nil {
		return utils.MarshalJSON(u.SubtitleInput, "", true)
	}

	return nil, errors.New("could not marshal union type Input: all fields are null")
}

// CreateMediaRequestMetadata - You can search for videos with specific key-value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have a maximum of 255 characters and up to 10 entries are allowed.
type CreateMediaRequestMetadata struct {
}

// SubtitleMetadata - You can search for videos with specific key-value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have a maximum of 255 characters and up to 10 entries are allowed.
type SubtitleMetadata struct {
}

// CreateMediaRequestLanguageCode - Language codes are concise, standardized symbols that denote languages, utilizing either two or three characters for identification. The language code must be compliant with the BCP 47 standard to ensure compatibility. (for text only).
type CreateMediaRequestLanguageCode string

const (
	CreateMediaRequestLanguageCodeEn CreateMediaRequestLanguageCode = "en"
	CreateMediaRequestLanguageCodeIt CreateMediaRequestLanguageCode = "it"
	CreateMediaRequestLanguageCodePl CreateMediaRequestLanguageCode = "pl"
	CreateMediaRequestLanguageCodeEs CreateMediaRequestLanguageCode = "es"
	CreateMediaRequestLanguageCodeFr CreateMediaRequestLanguageCode = "fr"
	CreateMediaRequestLanguageCodeRu CreateMediaRequestLanguageCode = "ru"
	CreateMediaRequestLanguageCodeNl CreateMediaRequestLanguageCode = "nl"
)

func (e CreateMediaRequestLanguageCode) ToPointer() *CreateMediaRequestLanguageCode {
	return &e
}
func (e *CreateMediaRequestLanguageCode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "en":
		fallthrough
	case "it":
		fallthrough
	case "pl":
		fallthrough
	case "es":
		fallthrough
	case "fr":
		fallthrough
	case "ru":
		fallthrough
	case "nl":
		*e = CreateMediaRequestLanguageCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateMediaRequestLanguageCode: %v", v)
	}
}

// Subtitle - Generates subtitle files for audio/video files.
type Subtitle struct {
	// Name of the language in which the subtitles will be generated.
	//
	LanguageName *string `json:"languageName,omitempty"`
	// You can search for videos with specific key-value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have a maximum of 255 characters and up to 10 entries are allowed.
	//
	Metadata *SubtitleMetadata `json:"metadata,omitempty"`
	// Language codes are concise, standardized symbols that denote languages, utilizing either two or three characters for identification. The language code must be compliant with the BCP 47 standard to ensure compatibility. (for text only).
	//
	LanguageCode *CreateMediaRequestLanguageCode `json:"languageCode,omitempty"`
}

func (o *Subtitle) GetLanguageName() *string {
	if o == nil {
		return nil
	}
	return o.LanguageName
}

func (o *Subtitle) GetMetadata() *SubtitleMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Subtitle) GetLanguageCode() *CreateMediaRequestLanguageCode {
	if o == nil {
		return nil
	}
	return o.LanguageCode
}

// CreateMediaRequestAccessPolicy - Determines whether access to the streamed content is kept private or available to all.
type CreateMediaRequestAccessPolicy string

const (
	CreateMediaRequestAccessPolicyPublic  CreateMediaRequestAccessPolicy = "public"
	CreateMediaRequestAccessPolicyPrivate CreateMediaRequestAccessPolicy = "private"
	CreateMediaRequestAccessPolicyDrm     CreateMediaRequestAccessPolicy = "drm"
)

func (e CreateMediaRequestAccessPolicy) ToPointer() *CreateMediaRequestAccessPolicy {
	return &e
}
func (e *CreateMediaRequestAccessPolicy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "public":
		fallthrough
	case "private":
		fallthrough
	case "drm":
		*e = CreateMediaRequestAccessPolicy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateMediaRequestAccessPolicy: %v", v)
	}
}

// CreateMediaRequestMp4Support - “capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline viewing
type CreateMediaRequestMp4Support string

const (
	CreateMediaRequestMp4SupportCapped4k          CreateMediaRequestMp4Support = "capped_4k"
	CreateMediaRequestMp4SupportAudioOnly         CreateMediaRequestMp4Support = "audioOnly"
	CreateMediaRequestMp4SupportAudioOnlyCapped4k CreateMediaRequestMp4Support = "audioOnly,capped_4k"
)

func (e CreateMediaRequestMp4Support) ToPointer() *CreateMediaRequestMp4Support {
	return &e
}
func (e *CreateMediaRequestMp4Support) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "capped_4k":
		fallthrough
	case "audioOnly":
		fallthrough
	case "audioOnly,capped_4k":
		*e = CreateMediaRequestMp4Support(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateMediaRequestMp4Support: %v", v)
	}
}

// CreateMediaRequestMaxResolution - The maximum resolution tier determines the highest quality your media will be available in.
type CreateMediaRequestMaxResolution string

const (
	CreateMediaRequestMaxResolutionTwoThousandOneHundredAndSixtyp  CreateMediaRequestMaxResolution = "2160p"
	CreateMediaRequestMaxResolutionOneThousandFourHundredAndFortyp CreateMediaRequestMaxResolution = "1440p"
	CreateMediaRequestMaxResolutionOneThousandAndEightyp           CreateMediaRequestMaxResolution = "1080p"
	CreateMediaRequestMaxResolutionSevenHundredAndTwentyp          CreateMediaRequestMaxResolution = "720p"
	CreateMediaRequestMaxResolutionFourHundredAndEightyp           CreateMediaRequestMaxResolution = "480p"
	CreateMediaRequestMaxResolutionThreeHundredAndSixtyp           CreateMediaRequestMaxResolution = "360p"
)

func (e CreateMediaRequestMaxResolution) ToPointer() *CreateMediaRequestMaxResolution {
	return &e
}
func (e *CreateMediaRequestMaxResolution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "2160p":
		fallthrough
	case "1440p":
		fallthrough
	case "1080p":
		fallthrough
	case "720p":
		fallthrough
	case "480p":
		fallthrough
	case "360p":
		*e = CreateMediaRequestMaxResolution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateMediaRequestMaxResolution: %v", v)
	}
}

type Summary struct {
	// Enable or disable the summary feature for the media. Set to true to enable summary or false to disable.
	//
	Generate bool `json:"generate"`
	// Specifies the desired word count for the generated summary.
	// - The value must be between **30** and **250** words.
	//
	SummaryLength *int64 `default:"100" json:"summaryLength"`
}

func (s Summary) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Summary) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Summary) GetGenerate() bool {
	if o == nil {
		return false
	}
	return o.Generate
}

func (o *Summary) GetSummaryLength() *int64 {
	if o == nil {
		return nil
	}
	return o.SummaryLength
}

// CreateMediaRequestType - Defines the type of input. Possible values include video, audio, av.
type CreateMediaRequestType string

const (
	CreateMediaRequestTypeVideo CreateMediaRequestType = "video"
	CreateMediaRequestTypeAudio CreateMediaRequestType = "audio"
	CreateMediaRequestTypeAv    CreateMediaRequestType = "av"
)

func (e CreateMediaRequestType) ToPointer() *CreateMediaRequestType {
	return &e
}
func (e *CreateMediaRequestType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "video":
		fallthrough
	case "audio":
		fallthrough
	case "av":
		*e = CreateMediaRequestType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateMediaRequestType: %v", v)
	}
}

type Moderation struct {
	// Defines the type of input. Possible values include video, audio, av.
	//
	Type CreateMediaRequestType `json:"type"`
}

func (o *Moderation) GetType() CreateMediaRequestType {
	if o == nil {
		return CreateMediaRequestType("")
	}
	return o.Type
}

// CreateMediaRequestDomainsDefaultPolicy - Specifies the default access policy for domains.
// If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` lists.
// If set to `deny`, all domains are denied access unless otherwise specified in the `allow` lists.
type CreateMediaRequestDomainsDefaultPolicy string

const (
	CreateMediaRequestDomainsDefaultPolicyAllow CreateMediaRequestDomainsDefaultPolicy = "allow"
	CreateMediaRequestDomainsDefaultPolicyDeny  CreateMediaRequestDomainsDefaultPolicy = "deny"
)

func (e CreateMediaRequestDomainsDefaultPolicy) ToPointer() *CreateMediaRequestDomainsDefaultPolicy {
	return &e
}
func (e *CreateMediaRequestDomainsDefaultPolicy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		fallthrough
	case "deny":
		*e = CreateMediaRequestDomainsDefaultPolicy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateMediaRequestDomainsDefaultPolicy: %v", v)
	}
}

type CreateMediaRequestDomains struct {
	// Specifies the default access policy for domains.
	// If set to `allow`, all domains are allowed access unless otherwise specified in the `deny` lists.
	// If set to `deny`, all domains are denied access unless otherwise specified in the `allow` lists.
	//
	DefaultPolicy *CreateMediaRequestDomainsDefaultPolicy `json:"defaultPolicy,omitempty"`
	// A list of domain names or patterns that are explicitly allowed access.
	// This list is only effective when the `defaultPolicy` is set to `deny`.
	//
	Allow []string `json:"allow,omitempty"`
	// A list of domain names or patterns that are explicitly denied access.
	// This list is only effective when the `defaultPolicy` is set to `allow`.
	//
	Deny []string `json:"deny,omitempty"`
}

func (o *CreateMediaRequestDomains) GetDefaultPolicy() *CreateMediaRequestDomainsDefaultPolicy {
	if o == nil {
		return nil
	}
	return o.DefaultPolicy
}

func (o *CreateMediaRequestDomains) GetAllow() []string {
	if o == nil {
		return nil
	}
	return o.Allow
}

func (o *CreateMediaRequestDomains) GetDeny() []string {
	if o == nil {
		return nil
	}
	return o.Deny
}

// CreateMediaRequestUserAgentsDefaultPolicy - Specifies the default access policy for user agents (browsers, bots, etc.).
// If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` lists.
// If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` lists.
type CreateMediaRequestUserAgentsDefaultPolicy string

const (
	CreateMediaRequestUserAgentsDefaultPolicyAllow CreateMediaRequestUserAgentsDefaultPolicy = "allow"
	CreateMediaRequestUserAgentsDefaultPolicyDeny  CreateMediaRequestUserAgentsDefaultPolicy = "deny"
)

func (e CreateMediaRequestUserAgentsDefaultPolicy) ToPointer() *CreateMediaRequestUserAgentsDefaultPolicy {
	return &e
}
func (e *CreateMediaRequestUserAgentsDefaultPolicy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "allow":
		fallthrough
	case "deny":
		*e = CreateMediaRequestUserAgentsDefaultPolicy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateMediaRequestUserAgentsDefaultPolicy: %v", v)
	}
}

type CreateMediaRequestUserAgents struct {
	// Specifies the default access policy for user agents (browsers, bots, etc.).
	// If set to `allow`, all user agents are allowed access unless otherwise specified in the `deny` lists.
	// If set to `deny`, all user agents are denied access unless otherwise specified in the `allow` lists.
	//
	DefaultPolicy *CreateMediaRequestUserAgentsDefaultPolicy `json:"defaultPolicy,omitempty"`
	// A list of user agents (identified by string names or patterns) that are explicitly allowed access.
	// This list is only effective when the `defaultPolicy` is set to `deny`.
	//
	Allow []string `json:"allow,omitempty"`
	// A list of user agents (identified by string names or patterns) that are explicitly denied access.
	// This list is only effective when the `defaultPolicy` is set to `allow`.
	//
	Deny []string `json:"deny,omitempty"`
}

func (o *CreateMediaRequestUserAgents) GetDefaultPolicy() *CreateMediaRequestUserAgentsDefaultPolicy {
	if o == nil {
		return nil
	}
	return o.DefaultPolicy
}

func (o *CreateMediaRequestUserAgents) GetAllow() []string {
	if o == nil {
		return nil
	}
	return o.Allow
}

func (o *CreateMediaRequestUserAgents) GetDeny() []string {
	if o == nil {
		return nil
	}
	return o.Deny
}

type CreateMediaRequestAccessRestrictions struct {
	Domains    *CreateMediaRequestDomains    `json:"domains,omitempty"`
	UserAgents *CreateMediaRequestUserAgents `json:"userAgents,omitempty"`
}

func (o *CreateMediaRequestAccessRestrictions) GetDomains() *CreateMediaRequestDomains {
	if o == nil {
		return nil
	}
	return o.Domains
}

func (o *CreateMediaRequestAccessRestrictions) GetUserAgents() *CreateMediaRequestUserAgents {
	if o == nil {
		return nil
	}
	return o.UserAgents
}

type CreateMediaRequest struct {
	Inputs []Input `json:"inputs"`
	// You can search for videos with specific key-value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have a maximum of 255 characters and up to 10 entries are allowed.
	//
	Metadata *CreateMediaRequestMetadata `json:"metadata,omitempty"`
	// Generates subtitle files for audio/video files.
	//
	Subtitle *Subtitle `json:"subtitle,omitempty"`
	// Determines whether access to the streamed content is kept private or available to all.
	//
	AccessPolicy CreateMediaRequestAccessPolicy `json:"accessPolicy"`
	// “capped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline viewing
	//
	Mp4Support *CreateMediaRequestMp4Support `json:"mp4Support,omitempty"`
	// The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
	SourceAccess *bool `json:"sourceAccess,omitempty"`
	// normalize volume of the audio track. This is available for pre-recorded content only.
	//
	OptimizeAudio *bool `default:"false" json:"optimizeAudio"`
	// The maximum resolution tier determines the highest quality your media will be available in.
	//
	MaxResolution *CreateMediaRequestMaxResolution `default:"1080p" json:"maxResolution"`
	Summary       *Summary                         `json:"summary,omitempty"`
	// Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to disable.
	//
	Chapters *bool `json:"chapters,omitempty"`
	// Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
	//
	NamedEntities      *bool                                 `json:"namedEntities,omitempty"`
	Moderation         *Moderation                           `json:"moderation,omitempty"`
	AccessRestrictions *CreateMediaRequestAccessRestrictions `json:"accessRestrictions,omitempty"`
}

func (c CreateMediaRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateMediaRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateMediaRequest) GetInputs() []Input {
	if o == nil {
		return []Input{}
	}
	return o.Inputs
}

func (o *CreateMediaRequest) GetMetadata() *CreateMediaRequestMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *CreateMediaRequest) GetSubtitle() *Subtitle {
	if o == nil {
		return nil
	}
	return o.Subtitle
}

func (o *CreateMediaRequest) GetAccessPolicy() CreateMediaRequestAccessPolicy {
	if o == nil {
		return CreateMediaRequestAccessPolicy("")
	}
	return o.AccessPolicy
}

func (o *CreateMediaRequest) GetMp4Support() *CreateMediaRequestMp4Support {
	if o == nil {
		return nil
	}
	return o.Mp4Support
}

func (o *CreateMediaRequest) GetSourceAccess() *bool {
	if o == nil {
		return nil
	}
	return o.SourceAccess
}

func (o *CreateMediaRequest) GetOptimizeAudio() *bool {
	if o == nil {
		return nil
	}
	return o.OptimizeAudio
}

func (o *CreateMediaRequest) GetMaxResolution() *CreateMediaRequestMaxResolution {
	if o == nil {
		return nil
	}
	return o.MaxResolution
}

func (o *CreateMediaRequest) GetSummary() *Summary {
	if o == nil {
		return nil
	}
	return o.Summary
}

func (o *CreateMediaRequest) GetChapters() *bool {
	if o == nil {
		return nil
	}
	return o.Chapters
}

func (o *CreateMediaRequest) GetNamedEntities() *bool {
	if o == nil {
		return nil
	}
	return o.NamedEntities
}

func (o *CreateMediaRequest) GetModeration() *Moderation {
	if o == nil {
		return nil
	}
	return o.Moderation
}

func (o *CreateMediaRequest) GetAccessRestrictions() *CreateMediaRequestAccessRestrictions {
	if o == nil {
		return nil
	}
	return o.AccessRestrictions
}

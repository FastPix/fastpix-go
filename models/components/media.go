// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/FastPix/fastpix-go/internal/utils"
	"time"
)

// MediaMetadata - You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
type MediaMetadata struct {
}

// MediaMaxResolution - The maximum resolution specified by the user for the media.
type MediaMaxResolution string

const (
	MediaMaxResolutionTwoThousandOneHundredAndSixtyp  MediaMaxResolution = "2160p"
	MediaMaxResolutionOneThousandFourHundredAndFortyp MediaMaxResolution = "1440p"
	MediaMaxResolutionOneThousandAndEightyp           MediaMaxResolution = "1080p"
	MediaMaxResolutionSevenHundredAndTwentyp          MediaMaxResolution = "720p"
	MediaMaxResolutionFourHundredAndEightyp           MediaMaxResolution = "480p"
	MediaMaxResolutionThreeHundredAndSixtyp           MediaMaxResolution = "360p"
)

func (e MediaMaxResolution) ToPointer() *MediaMaxResolution {
	return &e
}
func (e *MediaMaxResolution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "2160p":
		fallthrough
	case "1440p":
		fallthrough
	case "1080p":
		fallthrough
	case "720p":
		fallthrough
	case "480p":
		fallthrough
	case "360p":
		*e = MediaMaxResolution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MediaMaxResolution: %v", v)
	}
}

// SourceResolution - The actual resolution of the uploaded media. This represents the native quality of the source media.
type SourceResolution string

const (
	SourceResolutionTwoThousandOneHundredAndSixtyp  SourceResolution = "2160p"
	SourceResolutionOneThousandFourHundredAndFortyp SourceResolution = "1440p"
	SourceResolutionOneThousandAndEightyp           SourceResolution = "1080p"
	SourceResolutionSevenHundredAndTwentyp          SourceResolution = "720p"
	SourceResolutionFourHundredAndEightyp           SourceResolution = "480p"
	SourceResolutionThreeHundredAndSixtyp           SourceResolution = "360p"
)

func (e SourceResolution) ToPointer() *SourceResolution {
	return &e
}
func (e *SourceResolution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "2160p":
		fallthrough
	case "1440p":
		fallthrough
	case "1080p":
		fallthrough
	case "720p":
		fallthrough
	case "480p":
		fallthrough
	case "360p":
		*e = SourceResolution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceResolution: %v", v)
	}
}

// MediaMp4Support - Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
type MediaMp4Support string

const (
	MediaMp4SupportNone              MediaMp4Support = "none"
	MediaMp4SupportCapped4k          MediaMp4Support = "capped_4k"
	MediaMp4SupportAudioOnly         MediaMp4Support = "audioOnly"
	MediaMp4SupportAudioOnlyCapped4k MediaMp4Support = "audioOnly,capped_4k"
)

func (e MediaMp4Support) ToPointer() *MediaMp4Support {
	return &e
}
func (e *MediaMp4Support) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "capped_4k":
		fallthrough
	case "audioOnly":
		fallthrough
	case "audioOnly,capped_4k":
		*e = MediaMp4Support(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MediaMp4Support: %v", v)
	}
}

type Media struct {
	// A video thumbnail is a still image that acts as the preview image for your video.
	Thumbnail *string `json:"thumbnail,omitempty"`
	// When creating the media, FastPix assigns a universally unique identifier with a maximum length of 255 characters.
	ID *string `json:"id,omitempty"`
	// A unique identifier is generated by FastPix for the workspace.
	WorkspaceID *string `json:"workspaceId,omitempty"`
	// You can search for videos with specific key value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
	Metadata *MediaMetadata `json:"metadata,omitempty"`
	// The maximum resolution specified by the user for the media.
	MaxResolution *MediaMaxResolution `default:"1080p" json:"maxResolution"`
	// The actual resolution of the uploaded media. This represents the native quality of the source media.
	SourceResolution *SourceResolution `default:"1080p" json:"sourceResolution"`
	// Determines the media's status, which can be one of the possible values.
	Status *string `json:"status,omitempty"`
	// Determines the type of MP4 support for the media.   - **none**: Disables MP4 support.   - **capped_4k**: Enables MP4 downloads with resolutions up to 4K.   - **audioOnly**: Provides an MP4 stream containing only the audio.   - **audioOnly,capped_4k**: Enables both MP4 video downloads (up to 4K) and an audio-only stream.
	Mp4Support *MediaMp4Support `json:"mp4Support,omitempty"`
	// The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
	SourceAccess *bool `json:"sourceAccess,omitempty"`
	// A collection of Playback ID objects utilized for crafting HLS playback URLs.
	PlaybackIds []PlaybackID `json:"playbackIds,omitempty"`
	// A media consists of different media tracks, like video, audio, and subtitle, all combined.
	Tracks []Track `json:"tracks,omitempty"`
	// The time span of the media, measured in seconds with a maximum allowable duration of 12 hours per individual media.
	Duration *string `json:"duration,omitempty"`
	// Frame rate quantifies the speed at which frames are displayed per second. It represents the range of frames available for a specific track. If the frame rate of the input file is indeterminable, it will be indicated by a value of -1.
	FrameRate *string `json:"frameRate,omitempty"`
	// The aspect ratio of a video is a value that describes the relative shape of a video based on its width and height.
	AspectRatio *string `json:"aspectRatio,omitempty"`
	// Time the media was created, defined as a localDateTime (UTC Time).
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	// Time the media was updated, defined as a localDateTime (UTC Time).
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

func (m Media) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *Media) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Media) GetThumbnail() *string {
	if o == nil {
		return nil
	}
	return o.Thumbnail
}

func (o *Media) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Media) GetWorkspaceID() *string {
	if o == nil {
		return nil
	}
	return o.WorkspaceID
}

func (o *Media) GetMetadata() *MediaMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Media) GetMaxResolution() *MediaMaxResolution {
	if o == nil {
		return nil
	}
	return o.MaxResolution
}

func (o *Media) GetSourceResolution() *SourceResolution {
	if o == nil {
		return nil
	}
	return o.SourceResolution
}

func (o *Media) GetStatus() *string {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Media) GetMp4Support() *MediaMp4Support {
	if o == nil {
		return nil
	}
	return o.Mp4Support
}

func (o *Media) GetSourceAccess() *bool {
	if o == nil {
		return nil
	}
	return o.SourceAccess
}

func (o *Media) GetPlaybackIds() []PlaybackID {
	if o == nil {
		return nil
	}
	return o.PlaybackIds
}

func (o *Media) GetTracks() []Track {
	if o == nil {
		return nil
	}
	return o.Tracks
}

func (o *Media) GetDuration() *string {
	if o == nil {
		return nil
	}
	return o.Duration
}

func (o *Media) GetFrameRate() *string {
	if o == nil {
		return nil
	}
	return o.FrameRate
}

func (o *Media) GetAspectRatio() *string {
	if o == nil {
		return nil
	}
	return o.AspectRatio
}

func (o *Media) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Media) GetUpdatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}
